
/*
 * generated by event_generator
 *
 * DO NOT EDIT
 */

package tracker

import "github.com/joernweissenborn/eventual2go"



type NodeCompleter struct {
	*eventual2go.Completer
}

func NewNodeCompleter() *NodeCompleter {
	return &NodeCompleter{eventual2go.NewCompleter()}
}

func (c *NodeCompleter) Complete(d Node) {
	c.Completer.Complete(d)
}

func (c *NodeCompleter) Future() *NodeFuture {
	return &NodeFuture{c.Completer.Future()}
}

type NodeFuture struct {
	*eventual2go.Future
}

func (f *NodeFuture) GetResult() Node {
	return f.Future.GetResult().(Node)
}

type NodeCompletionHandler func(Node) Node

func (ch NodeCompletionHandler) toCompletionHandler() eventual2go.CompletionHandler {
	return func(d eventual2go.Data) eventual2go.Data {
		return ch(d.(Node))
	}
}

func (f *NodeFuture) Then(ch NodeCompletionHandler) *NodeFuture {
	return &NodeFuture{f.Future.Then(ch.toCompletionHandler())}
}

func (f *NodeFuture) AsChan() chan Node {
	c := make(chan Node, 1)
	cmpl := func(d chan Node) NodeCompletionHandler {
		return func(e Node) Node {
			d <- e
			close(d)
			return e
		}
	}
	ecmpl := func(d chan Node) eventual2go.ErrorHandler {
		return func(error) (eventual2go.Data, error) {
			close(d)
			return nil, nil
		}
	}
	f.Then(cmpl(c))
	f.Err(ecmpl(c))
	return c
}

type NodeStreamController struct {
	*eventual2go.StreamController
}

func NewNodeStreamController() *NodeStreamController {
	return &NodeStreamController{eventual2go.NewStreamController()}
}

func (sc *NodeStreamController) Add(d Node) {
	sc.StreamController.Add(d)
}

func (sc *NodeStreamController) Join(s *NodeStream) {
	sc.StreamController.Join(s.Stream)
}

func (sc *NodeStreamController) JoinFuture(f *NodeFuture) {
	sc.StreamController.JoinFuture(f.Future)
}

func (sc *NodeStreamController) Stream() *NodeStream {
	return &NodeStream{sc.StreamController.Stream()}
}

type NodeStream struct {
	*eventual2go.Stream
}

type NodeSubscriber func(Node)

func (l NodeSubscriber) toSubscriber() eventual2go.Subscriber {
	return func(d eventual2go.Data) { l(d.(Node)) }
}

func (s *NodeStream) Listen(ss NodeSubscriber) *eventual2go.Completer {
	return s.Stream.Listen(ss.toSubscriber())
}

type NodeFilter func(Node) bool

func (f NodeFilter) toFilter() eventual2go.Filter {
	return func(d eventual2go.Data) bool { return f(d.(Node)) }
}

func toNodeFilterArray(f ...NodeFilter) (filter []eventual2go.Filter){

	filter = make([]eventual2go.Filter, len(f))
	for i, el := range f {
		filter[i] = el.toFilter()
	}
	return
}

func (s *NodeStream) Where(f ...NodeFilter) *NodeStream {
	return &NodeStream{s.Stream.Where(toNodeFilterArray(f...)...)}
}

func (s *NodeStream) WhereNot(f ...NodeFilter) *NodeStream {
	return &NodeStream{s.Stream.WhereNot(toNodeFilterArray(f...)...)}
}

func (s *NodeStream) Split(f NodeFilter) (*NodeStream, *NodeStream)  {
	return s.Where(f), s.WhereNot(f)
}

func (s *NodeStream) First() *NodeFuture {
	return &NodeFuture{s.Stream.First()}
}

func (s *NodeStream) FirstWhere(f... NodeFilter) *NodeFuture {
	return &NodeFuture{s.Stream.FirstWhere(toNodeFilterArray(f...)...)}
}

func (s *NodeStream) FirstWhereNot(f ...NodeFilter) *NodeFuture {
	return &NodeFuture{s.Stream.FirstWhereNot(toNodeFilterArray(f...)...)}
}

func (s *NodeStream) AsChan() (c chan Node, stop *eventual2go.Completer) {
	c = make(chan Node)
	stop = s.Listen(pipeToNodeChan(c))
	stop.Future().Then(closeNodeChan(c))
	return
}

func pipeToNodeChan(c chan Node) NodeSubscriber {
	return func(d Node) {
		c <- d
	}
}

func closeNodeChan(c chan Node) eventual2go.CompletionHandler {
	return func(d eventual2go.Data) eventual2go.Data {
		close(c)
		return nil
	}
}

type NodeCollector struct {
	*eventual2go.Collector
}

func NewNodeCollector() *NodeCollector {
	return &NodeCollector{eventual2go.NewCollector()}
}

func (c *NodeCollector) Add(d Node) {
	c.Collector.Add(d)
}

func (c *NodeCollector) AddFuture(f *NodeFuture) {
	c.Collector.Add(f.Future)
}

func (c *NodeCollector) AddStream(s *NodeStream) {
	c.Collector.AddStream(s.Stream)
}

func (c *NodeCollector) Get() Node {
	return c.Collector.Get().(Node)
}

func (c *NodeCollector) Preview() Node {
	return c.Collector.Preview().(Node)
}
