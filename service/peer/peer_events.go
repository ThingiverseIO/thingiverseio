
/*
 * generated by event_generator
 *
 * DO NOT EDIT
 */

package peer

import "github.com/joernweissenborn/eventual2go"



type PeerCompleter struct {
	*eventual2go.Completer
}

func NewPeerCompleter() *PeerCompleter {
	return &PeerCompleter{eventual2go.NewCompleter()}
}

func (c *PeerCompleter) Complete(d *Peer) {
	c.Completer.Complete(d)
}

func (c *PeerCompleter) Future() *PeerFuture {
	return &PeerFuture{c.Completer.Future()}
}

type PeerFuture struct {
	*eventual2go.Future
}

func (f *PeerFuture) GetResult() *Peer {
	return f.Future.GetResult().(*Peer)
}

type PeerCompletionHandler func(*Peer) *Peer

func (ch PeerCompletionHandler) toCompletionHandler() eventual2go.CompletionHandler {
	return func(d eventual2go.Data) eventual2go.Data {
		return ch(d.(*Peer))
	}
}

func (f *PeerFuture) Then(ch PeerCompletionHandler) *PeerFuture {
	return &PeerFuture{f.Future.Then(ch.toCompletionHandler())}
}

func (f *PeerFuture) AsChan() chan *Peer {
	c := make(chan *Peer, 1)
	cmpl := func(d chan *Peer) PeerCompletionHandler {
		return func(e *Peer) *Peer {
			d <- e
			close(d)
			return e
		}
	}
	ecmpl := func(d chan *Peer) eventual2go.ErrorHandler {
		return func(error) (eventual2go.Data, error) {
			close(d)
			return nil, nil
		}
	}
	f.Then(cmpl(c))
	f.Err(ecmpl(c))
	return c
}

type PeerStreamController struct {
	*eventual2go.StreamController
}

func NewPeerStreamController() *PeerStreamController {
	return &PeerStreamController{eventual2go.NewStreamController()}
}

func (sc *PeerStreamController) Add(d *Peer) {
	sc.StreamController.Add(d)
}

func (sc *PeerStreamController) Join(s *PeerStream) {
	sc.StreamController.Join(s.Stream)
}

func (sc *PeerStreamController) JoinFuture(f *PeerFuture) {
	sc.StreamController.JoinFuture(f.Future)
}

func (sc *PeerStreamController) Stream() *PeerStream {
	return &PeerStream{sc.StreamController.Stream()}
}

type PeerStream struct {
	*eventual2go.Stream
}

type PeerSubscriber func(*Peer)

func (l PeerSubscriber) toSubscriber() eventual2go.Subscriber {
	return func(d eventual2go.Data) { l(d.(*Peer)) }
}

func (s *PeerStream) Listen(ss PeerSubscriber) *eventual2go.Completer {
	return s.Stream.Listen(ss.toSubscriber())
}

type PeerFilter func(*Peer) bool

func (f PeerFilter) toFilter() eventual2go.Filter {
	return func(d eventual2go.Data) bool { return f(d.(*Peer)) }
}

func toPeerFilterArray(f ...PeerFilter) (filter []eventual2go.Filter){

	filter = make([]eventual2go.Filter, len(f))
	for i, el := range f {
		filter[i] = el.toFilter()
	}
	return
}

func (s *PeerStream) Where(f ...PeerFilter) *PeerStream {
	return &PeerStream{s.Stream.Where(toPeerFilterArray(f...)...)}
}

func (s *PeerStream) WhereNot(f ...PeerFilter) *PeerStream {
	return &PeerStream{s.Stream.WhereNot(toPeerFilterArray(f...)...)}
}

func (s *PeerStream) Split(f PeerFilter) (*PeerStream, *PeerStream)  {
	return s.Where(f), s.WhereNot(f)
}

func (s *PeerStream) First() *PeerFuture {
	return &PeerFuture{s.Stream.First()}
}

func (s *PeerStream) FirstWhere(f... PeerFilter) *PeerFuture {
	return &PeerFuture{s.Stream.FirstWhere(toPeerFilterArray(f...)...)}
}

func (s *PeerStream) FirstWhereNot(f ...PeerFilter) *PeerFuture {
	return &PeerFuture{s.Stream.FirstWhereNot(toPeerFilterArray(f...)...)}
}

func (s *PeerStream) AsChan() (c chan *Peer, stop *eventual2go.Completer) {
	c = make(chan *Peer)
	stop = s.Listen(pipeToPeerChan(c))
	stop.Future().Then(closePeerChan(c))
	return
}

func pipeToPeerChan(c chan *Peer) PeerSubscriber {
	return func(d *Peer) {
		c <- d
	}
}

func closePeerChan(c chan *Peer) eventual2go.CompletionHandler {
	return func(d eventual2go.Data) eventual2go.Data {
		close(c)
		return nil
	}
}

type PeerCollector struct {
	*eventual2go.Collector
}

func NewPeerCollector() *PeerCollector {
	return &PeerCollector{eventual2go.NewCollector()}
}

func (c *PeerCollector) Add(d *Peer) {
	c.Collector.Add(d)
}

func (c *PeerCollector) AddFuture(f *PeerFuture) {
	c.Collector.Add(f.Future)
}

func (c *PeerCollector) AddStream(s *PeerStream) {
	c.Collector.AddStream(s.Stream)
}

func (c *PeerCollector) Get() *Peer {
	return c.Collector.Get().(*Peer)
}

func (c *PeerCollector) Preview() *Peer {
	return c.Collector.Preview().(*Peer)
}
